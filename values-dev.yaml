# Development Environment Configuration
# 2-node cluster with reduced resources

global:
  namespace: webmethods

replicaCount: 2

image:
  repository: abiwebmethods.azurecr.io/webmethods-microservicesruntime
  tag: "dev"
  pullPolicy: Always

service:
  type: ClusterIP
  ports:
    http: 5555
    https: 5543
    diagnostic: 9999

# Resources for dev
resources:
  requests:
    memory: "1Gi"
    cpu: "1000m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# JVM memory for dev
jvm:
  minMemory: "800m"
  maxMemory: "900m"

# Persistence
persistence:
  enabled: true
  storageClass: "default"
  accessMode: ReadWriteOnce
  size: 3Gi

# ============================================================================
# JDBC POOL Configuration (MSR Internal Database for ISInternal, Xref, etc.)
# ============================================================================
# JDBC Pools are used by MSR internal functions like ISInternal, ISDashboardStats, Xref
# Credentials stored in Azure Key Vault: jdbc-dev-url, jdbc-dev-username, jdbc-dev-password
# Pool sizing configuration is environment-specific and non-sensitive
jdbcPool:
  enabled: false
  pool:
    name: "IS-Pool"
    driverAlias: "DataDirect Connect JDBC SQL Server Driver"
    dataSourceClass: "com.ddtek.jdbc.sqlserver.SQLServerDataSource"
    minConns: 1
    maxConns: 100
    poolThreshold: 5
    waitingThread: 50
    expireTime: 60000
    useSSL: false
  functionalAliases:
    - name: "ISInternal"
      connPoolAlias: "IS-Pool"
      failFastMode: true
    - name: "ISDashboardStats"
      connPoolAlias: "IS-Pool"
      failFastMode: false
    - name: "Xref"
      connPoolAlias: "IS-Pool"
      failFastMode: true

# ============================================================================
# JDBC ADAPTER Configuration (WmJDBCAdapter for Integration Services)
# ============================================================================
# JDBC Adapter connections are used by business integration services
# Credentials stored in Azure Key Vault: jdbc-adapter-dev-url, jdbc-adapter-dev-username, jdbc-adapter-dev-password
# Each connection can have different pool sizing and transaction settings
jdbcAdapter:
  enabled: true
  connections:
    - name: "DBConnection"
      description: "Primary Database Connection for Integration Services"
      packageName: "WmJDBCAdapter"
      connectionType: "JDBC Adapter Connection"
      connectionFactoryInterface: "com.wm.adapter.wmjdbc.JDBCConnectionFactory"
      driverAlias: "Microsoft SQL Server Driver"
      dataSourceClass: "com.microsoft.sqlserver.jdbc.SQLServerDataSource"
      transactionType: "LOCAL_TRANSACTION"
      # Connection pool settings (separate from MSR JDBC Pool above)
      minPoolSize: 1
      maxPoolSize: 10
      poolIncrementSize: 1
      blockTimeout: 1000
      expireTimeout: 1000
      startupRetryCount: 0
      startupBackoffSecs: 10

# High availability with pod anti-affinity
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          topologyKey: kubernetes.io/hostname
          labelSelector:
            matchLabels:
              app: wm-msr

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Health Probes (faster for dev)
healthProbes:
  startup:
    enabled: true
    path: /
    port: 5555
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
  liveness:
    enabled: true
    path: /
    port: 5555
    initialDelaySeconds: 120
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3
  readiness:
    enabled: true
    path: /
    port: 5555
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

# Universal Messaging Configuration
um:
  enabled: false
  connectionEnabled: true
  connectionAlias: "IS_UM_CONNECTION"
  url: "nsp://wm-um.webmethods.svc.cluster.local:9000"
  user: "Administrator"
  password: "manage"
  useCSQ: "true"
  csqSize: "-1"
  csqDrainInOrder: "true"

# Terracotta Cache Manager Configuration
terracotta:
  enabled: false
  cacheManagerName: "IS_TERRACOTTA_CACHE"
  urls:
    - "terracotta-0.terracotta-service.webmethods.svc.cluster.local:9510"
    - "terracotta-1.terracotta-service.webmethods.svc.cluster.local:9510"
  # Only 2 Terracotta servers are deployed, matching StatefulSet replicas

# Keystore Configuration (example - no actual files mounted in dev)
# To use actual keystore files, add 'fileData' field with base64 encoded content
keystores: []
  # - aliasName: "DEFAULT_IS_KEYSTORE"
  #   description: "Default Integration Server Keystore for SSL/TLS"
  #   type: "PKCS12"
  #   provider: "SUN"
  #   location: "/opt/softwareag/IntegrationServer/config/security/keystore.p12"
  #   password: "manage"
  #   isHsm: false
  #   keys:
  #     - keyAliasName: "sslkey"
  #       keyAliasPassword: "manage"
  #   # fileData: ""  # Base64 encoded keystore file

# Truststore Configuration (example - no actual files mounted in dev)
truststores: []
  # - aliasName: "DEFAULT_IS_TRUSTSTORE"
  #   description: "Default Integration Server Truststore for SSL/TLS"
  #   type: "JKS"
  #   provider: "SUN"
  #   location: "/opt/softwareag/IntegrationServer/config/security/truststore.jks"
  #   password: "manage"
  #   # fileData: ""  # Base64 encoded truststore file

# Autoscaling Configuration
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# ============================================================================
# Azure Key Vault Integration
# ============================================================================
# Store certificates in Azure Key Vault for centralized management
# Two types of certificates can be stored:
#
# 1. KEYSTORE Certificate (Certificate + Private Key)
#    - Used for YOUR server's identity (SSL/TLS server certificate)
#    - Must be imported as PKCS12/PFX with private key
#    - CSI driver mounts both .crt and .key files
#    - Init container converts PEM to PKCS12 keystore
#
# 2. TRUSTSTORE Certificate (Certificate only, NO Private Key)
#    - Used for TRUSTED external parties (CA certs, partner certs)
#    - Imported as .crt, .cer, or .pem (no private key)
#    - CSI driver mounts only .crt file
#    - Init container combines multiple certs into PKCS12 truststore
#
# IMPORTANT: Azure Key Vault Access Requirements
# -----------------------------------------------
# The AKS kubelet managed identity must have access to the Key Vault.
# Use the following commands to grant access:
#
# 1. Get the kubelet identity Object ID (NOT Client ID):
#    az aks show --resource-group RG-AKS-WM-IS1 --name webmethods-cluster \
#      --query "identityProfile.kubeletidentity.objectId" -o tsv
#
# 2. Grant Key Vault access using the Object ID:
#    az keyvault set-policy --name wM-kv \
#      --object-id <OBJECT_ID_FROM_STEP_1> \
#      --secret-permissions get list \
#      --certificate-permissions get list
#
# For this cluster:
#   Client ID: a7aded62-361d-4d2e-9e17-f42b4a0f437c
#   Object ID: 24434424-b433-467a-b948-0e81e76595f2 (use this for Key Vault policy)
# ============================================================================
azureKeyVault:
  enabled: true
  vaultName: "wM-kv"
  tenantId: "6824e2ad-c1e1-4119-912d-c1f42857e416"
  clientId: "3448b62d-b43e-4b3f-af74-ab03bb68c1a2"  # AKS kubelet managed identity Client ID (CORRECTED)
  mountPath: "/mnt/secrets-store"

  # KEYSTORE Certificates (Certificate + Private Key)
  # These certificates represent YOUR server's identity
  # Upload to Azure Key Vault as Certificate with private key (PKCS12/PFX)
  # DISABLED: No keystore certificates configured for JDBC-only setup
  certificates: []

  # Additional secrets can be stored here (not commonly used)
  secrets: []

# ============================================================================
# TRUSTSTORE Configuration
# ============================================================================
# Truststore contains trusted certificates (CA certs, partner certs)
# Each certificate should be uploaded to Azure Key Vault as Certificate object
# WITHOUT private key (just the .crt file)
#
# How it works:
# 1. Upload trusted CA certificates to Azure Key Vault (Certificate section)
# 2. List them below in the certificates array
# 3. Init container fetches all certificates from Key Vault
# 4. Init container combines them into single PKCS12 truststore with --legacy flag
# 5. MSR loads the truststore
#
# Example: Upload a trusted CA certificate
#   az keyvault certificate import \
#     --vault-name wM-kv \
#     --name truststore-root-ca \
#     --file root-ca.crt
# ============================================================================
truststoreCertificates:
  enabled: false
  fileName: "wm_truststore.p12"
  aliasName: "WM_TRUSTSTORE"
  description: "webMethods Truststore from Azure Key Vault (Dev)"
  type: "PKCS12"
  provider: "SUN"
  password: "changeit"

  # List of trusted certificates to include in truststore
  # Each certificate must exist in Azure Key Vault (Secrets section as PEM files)
  # These certificates are public certificates only (no private keys)
  certificates:
    - certName: "truststore-root-ca"          # Root CA certificate (Secret in Key Vault)
      alias: "root-ca"                        # Alias in PKCS12 truststore
    - certName: "truststore-intermediate-ca"  # Intermediate CA certificate
      alias: "intermediate-ca"
    - certName: "truststore-partner-cert"     # Partner's public certificate (Partner Corp)
      alias: "partner-cert"
    - certName: "truststore-payment-gateway"  # Payment Gateway partner certificate
      alias: "payment-gateway"
    - certName: "truststore-banking-partner"  # Banking partner certificate (Global Bank)
      alias: "banking-partner"
