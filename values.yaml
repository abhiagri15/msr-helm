# webMethods MSR Helm Chart Values
# Multi-node Cluster Configuration

## Global Settings
global:
  namespace: webmethods

## Cluster Configuration
replicaCount: 2  # Start with 2 nodes, can be scaled up

## Image Configuration
image:
  repository: abiwebmethods.azurecr.io/webmethods-microservicesruntime
  tag: "11.1.0.6-postgresql-v2"
  pullPolicy: IfNotPresent

## Service Configuration
service:
  type: ClusterIP
  ports:
    http: 5555
    https: 5543
    diagnostic: 9999

## Resource Configuration
resources:
  requests:
    memory: "1Gi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "1000m"

## JVM Configuration
jvm:
  minMemory: "512m"
  maxMemory: "1024m"

## Persistent Storage (per pod)
persistence:
  enabled: true
  storageClass: "default"
  size: 5Gi
  accessMode: ReadWriteOnce

## JDBC Configuration (legacy - for backwards compatibility)
## NOTE: Use jdbcPool for MSR internal pools and jdbcAdapter for WmJDBCAdapter connections
jdbc:
  enabled: false  # Deprecated - use jdbcPool instead

## JDBC Pool Configuration (MSR Internal - ISInternal, Xref, ISDashboardStats)
## This creates the JDBC connection pool used by MSR for internal operations
## Credentials are injected via environment variables from the jdbc-secrets secret
jdbcPool:
  enabled: false  # Set to true to enable JDBC Pool
  pool:
    name: "IS-Pool"
    driverAlias: "PostgresqlDriver"
    dataSourceClass: "org.postgresql.ds.PGSimpleDataSource"
    minConns: 1
    maxConns: 25
    poolThreshold: 10
    waitingThread: 100
    expireTime: 60000
    useSSL: false
  functionalAliases:
    - name: "ISInternal"
      connPoolAlias: "IS-Pool"
      failFastMode: true
    - name: "ISDashboardStats"
      connPoolAlias: "IS-Pool"
      failFastMode: false
    - name: "Xref"
      connPoolAlias: "IS-Pool"
      failFastMode: true

## JDBC Adapter Configuration (WmJDBCAdapter connections)
## This creates adapter connections for the WmJDBCAdapter package
jdbcAdapter:
  enabled: false  # Set to true to enable JDBC Adapter connections
  connections: []
    # Example connection configuration:
    # - name: "AbTest3Connection"
    #   description: "JDBC Adapter Connection for AbTest3"
    #   packageName: "AbTest3"
    #   folderName: "connection"
    #   connectionType: "jdbc"
    #   connectionFactoryInterface: "javax.sql.DataSource"
    #   transactionType: "LOCAL_TRANSACTION"
    #   serverName: "${JDBC_ADAPTER_SERVER}"
    #   databaseName: "${JDBC_ADAPTER_DATABASE}"
    #   portNumber: "${JDBC_ADAPTER_PORT}"
    #   networkProtocol: ""
    #   user: "${JDBC_ADAPTER_USERNAME}"
    #   password: "${JDBC_ADAPTER_PASSWORD}"
    #   dataSourceClass: "com.microsoft.sqlserver.jdbc.SQLServerDataSource"
    #   otherProperties: "encrypt=true"
    #   minPoolSize: 1
    #   maxPoolSize: 10
    #   poolIncrementSize: 1
    #   blockTimeout: 30000
    #   expireTimeout: 60000
    #   startupRetryCount: 3
    #   startupBackoffSecs: 10

## Health Probes
healthProbes:
  startup:
    enabled: true
    path: /health
    port: 5555
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
  liveness:
    enabled: true
    path: /health
    port: 5555
    initialDelaySeconds: 120
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3
  readiness:
    enabled: true
    path: /health
    port: 5555
    initialDelaySeconds: 90
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

## Pod Disruption Budget (for high availability)
podDisruptionBudget:
  enabled: true
  minAvailable: 1

## Pod Anti-Affinity (spread pods across nodes)
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - wm-msr
          topologyKey: kubernetes.io/hostname

## Universal Messaging Configuration
um:
  enabled: false  # Set to false by default, override in environment-specific values
  connectionEnabled: true  # When UM is enabled, connection is enabled by default
  connectionAlias: "IS_UM_CONNECTION"
  url: "nsp://wm-um.webmethods.svc.cluster.local:9000"
  user: "Administrator"
  password: "manage"
  useCSQ: "true"
  csqSize: "-1"
  csqDrainInOrder: "true"

## Terracotta Cache Manager Configuration
terracotta:
  enabled: false  # Set to false by default, override in environment-specific values
  cacheManagerName: "IS_TERRACOTTA_CACHE"
  urls: []  # Array of Terracotta server URLs, e.g., ["terracotta-0.terracotta.svc:9510"]
  waitForReady: true  # Add init container to wait for Terracotta servers to be ready before starting MSR

## Keystore Configuration
## Multiple keystores can be configured, each with a unique alias name
keystores: []
  # - aliasName: "DEFAULT_IS_KEYSTORE"
  #   description: "Default Integration Server Keystore"
  #   type: "JKS"  # JKS, PKCS12
  #   provider: "SUN"  # SUN, BC, SunJSSE
  #   location: "/opt/softwareag/IntegrationServer/config/security/keystore.jks"
  #   password: "manage"
  #   isHsm: false
  #   keys: []
  #     # - keyAliasName: "sslkey"
  #     #   keyAliasPassword: "manage"

## Truststore Configuration
## Multiple truststores can be configured, each with a unique alias name
truststores: []
  # - aliasName: "DEFAULT_IS_TRUSTSTORE"
  #   description: "Default Integration Server Truststore"
  #   type: "JKS"  # JKS, PKCS12
  #   provider: "SUN"  # SUN, BC, SunJSSE
  #   location: "/opt/softwareag/IntegrationServer/config/security/truststore.jks"
  #   password: "manage"

## Autoscaling Configuration
autoscaling:
  enabled: false  # Set to false by default, override in environment-specific values
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

## Azure Key Vault Integration (using CSI driver)
## Retrieves certificates from Azure Key Vault and converts them to Java keystores/truststores
##
## How it works:
## 1. CSI Secrets Store Provider mounts certificates to /mnt/secrets-store/
## 2. Init container uses Azure CLI to download certificates with private keys
## 3. OpenSSL converts Azure's proprietary PFX format to PEM format
## 4. OpenSSL creates Java-compatible PKCS12 keystores
## 5. Java keytool creates truststores from public certificates
## 6. MSR loads keystores/truststores on startup
##
## Prerequisites:
## - Azure Key Vault created with certificates uploaded
## - AKS cluster with Azure Key Vault CSI driver enabled
## - Kubelet managed identity with Key Vault access (get, list permissions on secrets and certificates)
##
## Secret Key Naming Convention:
## All secrets in Azure Key Vault use environment-specific prefixes:
##   - dev_  : Development environment (e.g., dev-jdbc-pool-password)
##   - test_ : QA/Test environment (e.g., test-jdbc-pool-password)
##   - prod_ : Production environment (e.g., prod-jdbc-pool-password)
##
## For detailed setup instructions, see: AZURE_KEYVAULT_SETUP.md
azureKeyVault:
  enabled: false  # Set to true to enable Azure Key Vault integration
  vaultName: ""  # Name of the Azure Key Vault (e.g., "wM-kv")
  tenantId: ""  # Azure tenant ID (get from: az account show --query tenantId -o tsv)
  clientId: ""  # Client ID of the kubelet managed identity (get from: az aks show --query identityProfile.kubeletidentity.clientId -o tsv)

  # Environment-specific prefix for secret names in Azure Key Vault
  # Use "dev" for development, "test" for QA, "prod" for production
  # Secrets will be retrieved as: {secretKeyPrefix}-{secretName}
  # Example: dev-jdbc-pool-password, test-jdbc-pool-password, prod-jdbc-pool-password
  secretKeyPrefix: "dev"

  # Keystore Certificates (certificates with private keys)
  # These are downloaded using Azure CLI and converted to Java PKCS12 keystores by init container
  certificates: []
    # Example keystore certificate configuration:
    # - certName: "wm-cer"                      # Name of certificate in Azure Key Vault
    #   fileName: "wm_keystore.p12"             # Output keystore filename
    #   keystoreConfig:
    #     password: "changeit"                  # Keystore password
    #     keys:
    #       - keyAliasName: "wmservercert"      # Alias for the private key in keystore

  # Truststore Certificates (public certificates only)
  # These are mounted by CSI driver and imported into truststore by init container
  truststoreCerts: []
    # Example truststore certificate configuration:
    # - certName: "truststore-root-ca"          # Root CA certificate
    # - certName: "truststore-intermediate-ca"  # Intermediate CA certificate
    # - certName: "truststore-partner-cert"     # Partner/third-party certificate

  # Secrets from Azure Key Vault (for truststores configured via secrets)
  secrets: []
    # Example:
    # - fileName: "truststore.p12"
    #   truststoreConfig:
    #     aliasName: "WM_TRUSTSTORE"
    #     description: "webMethods Truststore"
    #     type: "PKCS12"
    #     provider: "SunJSSE"
    #     password: "changeit"

## Truststore Certificates Configuration
## Creates a combined truststore from multiple certificates in Azure Key Vault
truststoreCertificates:
  enabled: false  # Set to true to enable truststore creation from certificates
  fileName: "wm_truststore.p12"
  aliasName: "WM_TRUSTSTORE"
  description: "webMethods Truststore from Azure Key Vault"
  type: "PKCS12"
  provider: "SunJSSE"
  password: "changeit"
  certificates: []
    # Example certificates to import:
    # - certName: "truststore-root-ca"
    #   alias: "root-ca"
    # - certName: "truststore-partner-cert"
    #   alias: "partner-cert"

## Package Configurations (Environment-Specific app.properties)
## This section allows you to define environment-specific app.properties for
## each custom package. These configurations are mounted at runtime via ConfigMap.
packageConfigs:
  enabled: false  # Set to true to enable package-specific configurations
  packages: []
    # Example package configuration:
    # - name: MyPackage
    #   appProperties: |
    #     api.url=https://api.example.com/v1
    #     api.key=${MY_PACKAGE_API_KEY}
    #     timeout.seconds=30

## ============================================================================
## File Access Control Configuration (WmPublic package - pub.file services)
## ============================================================================
## Controls which directories/files the Integration Server pub.file services can access
## This creates the fileAccessControl.cnf file in WmPublic/config directory
##
## Path Specification Format:
## - Single files: Specify exact path to restrict access to that file only
## - Directories: Grant access to all files within that directory
## - Multiple paths: Use semicolons as delimiters (no spaces between entries)
## - Wildcards: * matches directory names; ** matches multiple nested folders
## - Paths are case-sensitive on Linux and must use forward slashes
##
## Reference: https://www.ibm.com/docs/en/webmethods-integration/wm-integration-server/10.15.0?topic=guide-file-folder
## ============================================================================
fileAccessControl:
  enabled: false  # Set to true to enable file access control configuration

  # Directories/files with read permission for pub.file services
  # Example: /tmp;/opt/data;/mnt/shared/**
  allowedReadPaths: ""

  # Directories/files with write permission for pub.file services
  # Example: /tmp;/opt/data/output
  allowedWritePaths: ""

  # Directories/files with delete permission for pub.file services
  # Example: /tmp
  allowedDeletePaths: ""
